# Configurable Methods System

This package provides a configurable system for defining analysis methods, detectors, and filters specific to different scientific instruments. Instead of hardcoding these elements into the models, the system allows them to be configured dynamically through a database-driven approach.

## Overview

The system consists of the following components:

1. **Configuration Models**:
   - `AnalysisMethod`: Defines an analysis method (e.g., PIXE, XRF, Tomography)
   - `DetectorType`: Defines a detector for a specific method
   - `FilterOption`: Defines filter options for a detector
   - `FilterSet`: Groups filters for a detector

2. **Dynamic Model Generation**:
   - `MethodConfiguration`: Utility class that generates fields based on the configuration
   - `ConfigurableMethodModel`: Abstract model that implements the methods dynamically

3. **Management Command**:
   - `init_method_configuration`: Command to initialize the configuration from JSON or defaults

## Getting Started

### Initial Setup

When setting up a new instance for a specific machine, you need to define its methods, detectors, and filters:

```bash
# Initialize with the default New Aglae configuration (particle accelerator)
python manage.py init_method_configuration --default

# OR initialize from a custom JSON configuration
python manage.py init_method_configuration --from-json path/to/config.json
```

### JSON Configuration Format

The JSON configuration should follow this structure:

```json
{
  "methods": [
    {
      "name": "Method Name",
      "description": "Method description",
      "detectors": [
        {
          "name": "Detector Name",
          "is_other_field": false,
          "filters": ["Filter 1", "Filter 2"]
        },
        {
          "name": "Custom Detector",
          "is_other_field": true
        }
      ]
    }
  ]
}
```

Two example configurations are provided in this package:
- `sample_configuration_tomography.json`: Example for a tomography machine
- `sample_configuration_xrf.json`: Example for an X-ray fluorescence machine

### Admin Interface

The system provides an admin interface for managing methods, detectors, and filters. This allows for adjustments after the initial setup:

- **Methods Admin**: Add, edit, or disable analysis methods
- **Detectors Admin**: Configure detectors and their relationship to methods
- **Filters Admin**: Manage filter options for each detector

## Migration Notes

When migrating from the hardcoded system to the configurable system:

1. Create a migration to add the configuration models (`AnalysisMethod`, `DetectorType`, etc.):
   ```bash
   python manage.py makemigrations lab.methods
   ```

2. Apply the migration to create the configuration tables:
   ```bash
   python manage.py migrate lab.methods
   ```

3. Initialize the configuration (from default or JSON):
   ```bash
   python manage.py init_method_configuration --default
   ```

4. Create a data migration to associate existing data with the new configuration:
   ```bash
   python manage.py makemigrations lab.methods --empty --name=migrate_method_data
   ```

5. Edit the data migration to handle the conversion from hardcoded fields to configurable fields.

6. Update model references in your code to use `ConfigurableMethodModel` instead of `MethodModel`

7. Create a schema migration for any models that need to use the new `ConfigurableMethodModel`:
   ```bash
   python manage.py makemigrations lab
   ```

8. Apply all migrations:
   ```bash
   python manage.py migrate
   ```

### Example Data Migration

```python
# Generated by Django x.y.z
import json
from django.db import migrations

def forward_data_migration(apps, schema_editor):
    """
    Migrate data from the old hardcoded fields to the new configurable fields.
    """
    Run = apps.get_model('lab', 'Run')
    
    # Example: Copy values from old fields to new fields
    for run in Run.objects.all():
        # Handle method fields
        if getattr(run, 'method_PIXE', False):
            setattr(run, 'method_pixe', True)
        
        # Handle detector fields
        if getattr(run, 'detector_LE0', False):
            setattr(run, 'detector_pixe_le0', True)
            
        # Handle filter fields
        old_filter = getattr(run, 'filters_for_detector_LE0', '')
        if old_filter:
            setattr(run, 'filters_for_detector_le0', old_filter)
            
        run.save()

def reverse_data_migration(apps, schema_editor):
    """
    Revert the data migration (copy values back to old fields).
    """
    # Similar to the forward migration, but copying in reverse
    pass

class Migration(migrations.Migration):
    dependencies = [
        ('lab', '0xxx_previous_migration'),
    ]

    operations = [
        migrations.RunPython(forward_data_migration, reverse_data_migration),
    ]
```

## Creating Templates for New Machines

To create a configuration for a new machine:

1. Identify the analysis methods, detectors, and filters used by the machine
2. Create a JSON file following the format above
3. Use the management command to initialize the configuration

## Technical Details

### Field Generation

Fields are generated dynamically based on the database configuration. Each method, detector, and filter set corresponds to a field in the model:

- Methods use `MethodBooleanField`
- Detectors use either `DetectorBooleanField` or `DetectorCharField` (for custom values)
- Filters use `FiltersCharField` with options from the database

### Field Naming

Field names are important for backward compatibility and consistency:

- Method fields: `method_[slugified_method_name]`
- Detector fields: `detector_[slugified_method_name]_[slugified_detector_name]`
- Filter fields: `filters_for_detector_[slugified_detector_name]`

The slugification process replaces spaces with underscores and removes special characters.

## Extending the System

To extend the system with additional functionality:

1. Add new fields to the configuration models as needed
2. Update the field generation logic in `MethodConfiguration`
3. Create migrations for the new fields